<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Mood Extractor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            padding: 40px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
            transition: background 0.8s ease;
        }

        .main-content.with-palette {
            background: linear-gradient(-45deg, var(--color1), var(--color2), var(--color3), var(--color4));
            background-size: 400% 400%;
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .upload-section {
            border: 3px dashed #e0e6ed;
            border-radius: 15px;
            padding: 60px 40px;
            text-align: center;
            margin-bottom: 40px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #f8fafc;
        }

        .upload-section:hover {
            border-color: #667eea;
            background: #f1f5f9;
        }

        .upload-section.dragover {
            border-color: #667eea;
            background: #e0e7ff;
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #94a3b8;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #64748b;
            margin-bottom: 15px;
        }

        .upload-subtext {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        #fileInput {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s ease;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .image-preview {
            display: none;
            text-align: center;
            margin-bottom: 40px;
        }

        .preview-img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border: 4px solid transparent;
            transition: all 0.5s ease;
            display: block;
            margin: 0 auto 20px auto;
        }

        .palette-section {
            display: none;
        }

        .palette-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 30px;
            text-align: center;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .color-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .color-card:hover {
            transform: translateY(-5px);
        }

        .color-swatch {
            height: 120px;
            width: 100%;
        }

        .color-info {
            padding: 20px;
            text-align: center;
        }

        .color-hex {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 5px;
        }

        .color-rgb {
            font-size: 0.9rem;
            color: #64748b;
        }

        .mood-section {
            background: #f8fafc;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            text-align: center;
        }

        .mood-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 15px;
        }

        .mood-description {
            font-size: 1.1rem;
            color: #64748b;
            line-height: 1.6;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e6ed;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .copy-notification.show {
            transform: translateX(0);
        }

        .social-generator {
            background: #f8fafc;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            text-align: center;
        }

        .social-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 10px;
        }

        .social-subtitle {
            color: #64748b;
            margin-bottom: 25px;
            font-size: 1rem;
        }

        .aspect-ratio-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .aspect-btn {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
            color: #475569;
            text-align: center;
        }

        .aspect-btn:hover {
            border-color: #667eea;
            background: #f1f5f9;
            transform: translateY(-2px);
        }

        .aspect-btn span {
            display: block;
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
            font-weight: 400;
        }

        .generated-preview {
            text-align: center;
            margin-top: 25px;
        }

        .generated-preview h4 {
            color: #1e293b;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .download-btn {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.2s ease;
        }

        .download-btn:hover {
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 30px 20px;
            }
            
            .upload-section {
                padding: 40px 20px;
            }
            
            .color-palette {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® Color Mood Extractor</h1>
            <p>Upload an image and discover its beautiful color palette</p>
        </div>

        <div class="main-content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üì∏</div>
                <div class="upload-text">Drop your image here or click to browse</div>
                <div class="upload-subtext">Supports JPG, PNG, GIF up to 10MB</div>
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    Choose Image
                </button>
                <input type="file" id="fileInput" accept="image/*">
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Extracting colors from your image...</p>
            </div>

            <div class="image-preview" id="imagePreview">
                <img id="previewImg" class="preview-img" alt="Preview">
                <button class="upload-btn" id="tryAnotherBtn" onclick="resetUploader()">
                    Try Another Image
                </button>
            </div>

            <div class="palette-section" id="paletteSection">
                <h2 class="palette-title">‚ú® Extracted Color Palette</h2>
                <div class="color-palette" id="colorPalette"></div>
                
                <div class="mood-section">
                    <h3 class="mood-title">üåà Color Mood</h3>
                    <p class="mood-description" id="moodDescription">
                        Click on any color to copy its hex code!
                    </p>
                </div>

                <div class="social-generator">
                    <h3 class="social-title">üì± Generate Social Media Image</h3>
                    <p class="social-subtitle">Create perfectly sized images for any platform</p>
                    
                    <div style="margin-bottom: 25px;">
                        <label for="watermarkInput" style="display: block; color: #64748b; margin-bottom: 8px; font-weight: 500;">Add your handle (optional):</label>
                        <input type="text" id="watermarkInput" placeholder="@your_handle" 
                               style="padding: 10px 15px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 1rem; width: 200px; text-align: center; background: white;">
                    </div>
                    
                    <div class="aspect-ratio-grid">
                        <button class="aspect-btn" onclick="generateSocialImage(1, 1, 'Instagram Square')">
                            üì∑ Instagram Square<br><span>1:1</span>
                        </button>
                        <button class="aspect-btn" onclick="generateSocialImage(9, 16, 'Instagram Story')">
                            üì± Instagram Story<br><span>9:16</span>
                        </button>
                        <button class="aspect-btn" onclick="generateSocialImage(16, 9, 'Facebook Post')">
                            üìò Facebook Post<br><span>16:9</span>
                        </button>
                        <button class="aspect-btn" onclick="generateSocialImage(3, 1, 'Twitter Header')">
                            üê¶ Twitter Header<br><span>3:1</span>
                        </button>
                        <button class="aspect-btn" onclick="generateSocialImage(4, 5, 'LinkedIn Post')">
                            üíº LinkedIn Post<br><span>4:5</span>
                        </button>
                        <button class="aspect-btn" onclick="generateSocialImage(16, 9, 'YouTube Thumbnail')">
                            üé• YouTube Thumb<br><span>16:9</span>
                        </button>
                    </div>

                    <div class="generated-preview" id="generatedPreview" style="display: none;">
                        <h4>Preview:</h4>
                        <div style="position: relative; display: inline-block;">
                            <canvas id="socialCanvas" style="max-width: 100%; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);"></canvas>
                            
                            <!-- Image Editor Overlay -->
                            <div id="imageEditor" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.1); border-radius: 10px;">
                                <!-- Editor Toolbar -->
                                <div id="editorToolbar" style="position: absolute; top: -60px; left: 0; right: 0; background: white; border-radius: 10px; padding: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: flex; gap: 10px; align-items: center; justify-content: center; flex-wrap: wrap;">
                                    <button class="editor-btn" id="addTextBtn" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">üìù Add Text</button>
                                    <button class="editor-btn" id="drawBtn" style="background: #10b981; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">‚úèÔ∏è Draw</button>
                                    <button class="editor-btn" id="arrowBtn" style="background: #f59e0b; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">‚û°Ô∏è Arrow</button>
                                    <button class="editor-btn" id="shapeBtn" style="background: #8b5cf6; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">üî∑ Shapes</button>
                                    <button class="editor-btn" id="undoBtn" style="background: #6b7280; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">‚Ü∂ Undo</button>
                                    <button class="editor-btn" id="doneEditingBtn" style="background: #ef4444; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; cursor: pointer;">‚úì Done</button>
                                </div>
                                
                                <!-- Color Picker -->
                                <div id="colorPicker" style="position: absolute; top: -120px; right: 0; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: none;">
                                    <div style="display: flex; gap: 5px; flex-wrap: wrap; width: 120px;">
                                        <div class="color-option" data-color="#000000" style="width: 20px; height: 20px; background: #000000; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#ffffff" style="width: 20px; height: 20px; background: #ffffff; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#ef4444" style="width: 20px; height: 20px; background: #ef4444; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#10b981" style="width: 20px; height: 20px; background: #10b981; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#3b82f6" style="width: 20px; height: 20px; background: #3b82f6; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#f59e0b" style="width: 20px; height: 20px; background: #f59e0b; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#8b5cf6" style="width: 20px; height: 20px; background: #8b5cf6; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                        <div class="color-option" data-color="#f97316" style="width: 20px; height: 20px; background: #f97316; border-radius: 50%; cursor: pointer; border: 2px solid #ddd;"></div>
                                    </div>
                                </div>
                                
                                <!-- Brush Size Picker -->
                                <div id="brushSizePicker" style="position: absolute; top: -120px; left: 0; background: white; border-radius: 8px; padding: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: none;">
                                    <div style="display: flex; flex-direction: column; gap: 5px;">
                                        <div class="brush-size" data-size="2" style="width: 20px; height: 2px; background: #333; cursor: pointer; border-radius: 1px;"></div>
                                        <div class="brush-size" data-size="5" style="width: 20px; height: 5px; background: #333; cursor: pointer; border-radius: 2px;"></div>
                                        <div class="brush-size" data-size="10" style="width: 20px; height: 10px; background: #333; cursor: pointer; border-radius: 5px;"></div>
                                        <div class="brush-size" data-size="15" style="width: 20px; height: 15px; background: #333; cursor: pointer; border-radius: 7px;"></div>
                                    </div>
                                </div>
                                
                                <!-- Text Input Modal -->
                                <div id="textInputModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 1000;">
                                    <h4 style="margin-bottom: 15px; color: #1e293b;">Add Text</h4>
                                    <input type="text" id="textInput" placeholder="Enter your text..." style="width: 250px; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; margin-bottom: 15px; font-size: 1rem;">
                                    <div style="margin-bottom: 15px;">
                                        <label style="display: block; margin-bottom: 5px; color: #64748b;">Font Size:</label>
                                        <select id="fontSizeSelect" style="padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; width: 100%;">
                                            <option value="16">Small</option>
                                            <option value="24" selected>Medium</option>
                                            <option value="32">Large</option>
                                            <option value="48">Extra Large</option>
                                        </select>
                                    </div>
                                    <div style="margin-bottom: 15px;">
                                        <label style="display: block; margin-bottom: 5px; color: #64748b;">Font:</label>
                                        <select id="fontFamilySelect" style="padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; width: 100%;">
                                            <option value="Arial, sans-serif">Arial</option>
                                            <option value="'Times New Roman', serif">Times New Roman</option>
                                            <option value="'Courier New', monospace">Courier New</option>
                                            <option value="'Comic Sans MS', cursive">Comic Sans</option>
                                            <option value="Impact, sans-serif">Impact</option>
                                        </select>
                                    </div>
                                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                        <button id="cancelTextBtn" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Cancel</button>
                                        <button id="addTextConfirmBtn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Add Text</button>
                                    </div>
                                </div>
                                
                                <!-- Shape Selector -->
                                <div id="shapeSelector" style="position: absolute; top: -120px; left: 50%; transform: translateX(-50%); background: white; border-radius: 8px; padding: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: none;">
                                    <div style="display: flex; gap: 10px;">
                                        <button class="shape-btn" data-shape="rectangle" style="background: #f3f4f6; border: 2px solid #d1d5db; padding: 8px; border-radius: 6px; cursor: pointer;">‚¨ú Rectangle</button>
                                        <button class="shape-btn" data-shape="circle" style="background: #f3f4f6; border: 2px solid #d1d5db; padding: 8px; border-radius: 6px; cursor: pointer;">‚≠ï Circle</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 15px;">
                            <button class="upload-btn" id="refreshBtn" style="margin-right: 10px;">
                                üîÑ New Background
                            </button>
                            <button class="upload-btn" id="editImageBtn" style="margin-right: 10px;">
                                ‚úèÔ∏è Edit Image
                            </button>
                            <button class="download-btn" id="downloadBtn">
                                üíæ Download Image
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="copy-notification" id="copyNotification">
        Color copied to clipboard! üéâ
    </div>

    <script>
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const loading = document.getElementById('loading');
        const imagePreview = document.getElementById('imagePreview');
        const previewImg = document.getElementById('previewImg');
        const paletteSection = document.getElementById('paletteSection');
        const colorPalette = document.getElementById('colorPalette');
        const moodDescription = document.getElementById('moodDescription');
        const copyNotification = document.getElementById('copyNotification');

        // Drag and drop functionality
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadSection.addEventListener('click', (e) => {
            // Only trigger file input if clicking the section itself, not the button
            if (e.target === uploadSection || e.target.classList.contains('upload-icon') || e.target.classList.contains('upload-text') || e.target.classList.contains('upload-subtext')) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                alert('File size must be less than 10MB.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                previewImg.src = e.target.result;
                showLoading();
                setTimeout(() => {
                    extractColors(e.target.result);
                }, 500);
            };
            reader.readAsDataURL(file);
        }

        function showLoading() {
            uploadSection.style.display = 'none';
            loading.style.display = 'block';
            imagePreview.style.display = 'none';
            paletteSection.style.display = 'none';
        }

        function extractColors(imageSrc) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = () => {
                // Store original image for social media generation
                originalImage = img;
                
                // Resize image for faster processing
                const maxSize = 200;
                const ratio = Math.min(maxSize / img.width, maxSize / img.height);
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;

                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const colors = getColorPalette(imageData.data);
                
                displayResults(colors);
            };

            img.src = imageSrc;
        }

        function getColorPalette(data) {
            const colorMap = new Map();
            const step = 4; // Sample every 4th pixel for performance

            // Collect color data
            for (let i = 0; i < data.length; i += step * 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                if (a < 128) continue; // Skip transparent pixels

                // Group similar colors
                const key = `${Math.floor(r/20)*20},${Math.floor(g/20)*20},${Math.floor(b/20)*20}`;
                colorMap.set(key, (colorMap.get(key) || 0) + 1);
            }

            // Sort by frequency and get top colors
            const sortedColors = Array.from(colorMap.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 6)
                .map(([color]) => {
                    const [r, g, b] = color.split(',').map(Number);
                    return { r, g, b };
                });

            return sortedColors;
        }

        function displayResults(colors) {
            loading.style.display = 'none';
            imagePreview.style.display = 'block';
            paletteSection.style.display = 'block';

            // Store colors and image for social media generation
            extractedColors = colors;

            // Clear previous palette
            colorPalette.innerHTML = '';

            colors.forEach((color, index) => {
                const hex = rgbToHex(color.r, color.g, color.b);
                const colorCard = createColorCard(color, hex);
                colorPalette.appendChild(colorCard);
            });

            // Generate mood description
            const mood = generateMoodDescription(colors);
            moodDescription.textContent = mood;

            // Apply dynamic styling with extracted colors
            applyDynamicStyling(colors);
        }

        function applyDynamicStyling(colors) {
            const mainContent = document.querySelector('.main-content');
            const previewImg = document.getElementById('previewImg');
            
            // Create gradient background using extracted colors
            if (colors.length >= 4) {
                const color1 = rgbToHex(colors[0].r, colors[0].g, colors[0].b);
                const color2 = rgbToHex(colors[1].r, colors[1].g, colors[1].b);
                const color3 = rgbToHex(colors[2].r, colors[2].g, colors[2].b);
                const color4 = rgbToHex(colors[3].r, colors[3].g, colors[3].b);
                
                // Set CSS custom properties for the gradient
                mainContent.style.setProperty('--color1', color1 + '40'); // Add transparency
                mainContent.style.setProperty('--color2', color2 + '40');
                mainContent.style.setProperty('--color3', color3 + '40');
                mainContent.style.setProperty('--color4', color4 + '40');
                
                // Add the gradient class
                mainContent.classList.add('with-palette');
                
                // Create a beautiful border using the dominant colors
                const borderGradient = `linear-gradient(45deg, ${color1}, ${color2}, ${color3})`;
                previewImg.style.border = '4px solid transparent';
                previewImg.style.background = borderGradient;
                previewImg.style.backgroundClip = 'padding-box';
                previewImg.style.boxShadow = `0 10px 30px rgba(0,0,0,0.2), inset 0 0 0 4px white`;
            }
        }

        function createColorCard(color, hex) {
            const card = document.createElement('div');
            card.className = 'color-card';
            card.onclick = () => copyToClipboard(hex);

            card.innerHTML = `
                <div class="color-swatch" style="background-color: ${hex}"></div>
                <div class="color-info">
                    <div class="color-hex">${hex}</div>
                    <div class="color-rgb">RGB(${color.r}, ${color.g}, ${color.b})</div>
                </div>
            `;

            return card;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function generateMoodDescription(colors) {
            const moods = [
                "This palette evokes a sense of calm and tranquility, perfect for peaceful moments.",
                "These colors create a vibrant and energetic atmosphere, full of life and creativity.",
                "A harmonious blend that suggests balance and natural beauty.",
                "This combination radiates warmth and comfort, like a cozy embrace.",
                "These hues inspire confidence and sophistication, ideal for modern designs.",
                "A palette that whispers of adventure and exploration, bold yet refined."
            ];

            return moods[Math.floor(Math.random() * moods.length)];
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showCopyNotification();
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyNotification();
            });
        }

        function showCopyNotification() {
            copyNotification.classList.add('show');
            setTimeout(() => {
                copyNotification.classList.remove('show');
            }, 2000);
        }

        let extractedColors = [];
        let originalImage = null;
        let currentPlatformSettings = null;
        
        // Image Editor Variables
        let isEditing = false;
        let currentTool = null;
        let isDrawing = false;
        let isDrawingArrow = false;
        let isDrawingShape = false;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let currentShape = 'rectangle';
        let startX, startY;
        let editHistory = [];
        let textElements = [];
        let editorCanvas, editorCtx;
        let isDragging = false;
        let draggedTextIndex = -1;
        let dragOffset = { x: 0, y: 0 };

        function generateSocialImage(widthRatio, heightRatio, platformName) {
            if (!originalImage || extractedColors.length === 0) {
                alert('Please upload an image first!');
                return;
            }

            // Store current settings for refresh functionality
            currentPlatformSettings = { widthRatio, heightRatio, platformName };
            
            drawSocialImage();
        }

        function drawSocialImage() {
            const canvas = document.getElementById('socialCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions based on aspect ratio - HIGH QUALITY
            const baseSize = 1200; // Doubled for higher quality
            let canvasWidth, canvasHeight;
            
            if (currentPlatformSettings.widthRatio >= currentPlatformSettings.heightRatio) {
                canvasWidth = baseSize;
                canvasHeight = (baseSize * currentPlatformSettings.heightRatio) / currentPlatformSettings.widthRatio;
            } else {
                canvasHeight = baseSize;
                canvasWidth = (baseSize * currentPlatformSettings.widthRatio) / currentPlatformSettings.heightRatio;
            }
            
            // Enable high-quality rendering
            canvas.style.imageRendering = 'high-quality';
            canvas.style.imageRendering = '-webkit-optimize-contrast';
            canvas.style.imageRendering = 'crisp-edges';
            canvas.style.imageRendering = 'pixelated';
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Create gradient background using extracted colors (randomized)
            const shuffledColors = [...extractedColors].sort(() => Math.random() - 0.5);
            const gradientType = Math.random();
            let gradient;
            
            if (gradientType < 0.33) {
                // Linear gradient
                gradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
            } else if (gradientType < 0.66) {
                // Radial gradient
                gradient = ctx.createRadialGradient(canvasWidth/2, canvasHeight/2, 0, canvasWidth/2, canvasHeight/2, Math.max(canvasWidth, canvasHeight)/2);
            } else {
                // Diagonal gradient
                gradient = ctx.createLinearGradient(0, canvasHeight, canvasWidth, 0);
            }
            
            if (shuffledColors.length >= 2) {
                gradient.addColorStop(0, rgbToHex(shuffledColors[0].r, shuffledColors[0].g, shuffledColors[0].b));
                gradient.addColorStop(0.5, rgbToHex(shuffledColors[1].r, shuffledColors[1].g, shuffledColors[1].b));
                if (shuffledColors.length >= 3) {
                    gradient.addColorStop(1, rgbToHex(shuffledColors[2].r, shuffledColors[2].g, shuffledColors[2].b));
                } else {
                    gradient.addColorStop(1, rgbToHex(shuffledColors[0].r, shuffledColors[0].g, shuffledColors[0].b));
                }
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Calculate image positioning to fit nicely
            const img = originalImage;
            const imgAspect = img.width / img.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            // Center the image with some padding
            const padding = Math.min(canvasWidth, canvasHeight) * 0.1;
            const availableWidth = canvasWidth - (padding * 2);
            const availableHeight = canvasHeight - (padding * 2);
            
            if (imgAspect > availableWidth / availableHeight) {
                drawWidth = availableWidth;
                drawHeight = availableWidth / imgAspect;
            } else {
                drawHeight = availableHeight;
                drawWidth = availableHeight * imgAspect;
            }
            
            drawX = (canvasWidth - drawWidth) / 2;
            drawY = (canvasHeight - drawHeight) / 2;

            // Save context for clipping
            ctx.save();

            // Add a subtle shadow behind the image
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 10;

            // Draw the image with rounded corners
            const cornerRadius = 15;
            ctx.beginPath();
            ctx.roundRect(drawX, drawY, drawWidth, drawHeight, cornerRadius);
            ctx.clip();
            // Enable high-quality image smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            
            // Reset shadow and clipping
            ctx.restore();

            // Add a beautiful gradient border around the entire canvas
            ctx.save();
            const borderWidth = Math.max(8, Math.min(canvasWidth, canvasHeight) * 0.02);
            
            // Create border gradient using extracted colors
            const borderGradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
            if (shuffledColors.length >= 3) {
                borderGradient.addColorStop(0, rgbToHex(shuffledColors[0].r, shuffledColors[0].g, shuffledColors[0].b));
                borderGradient.addColorStop(0.5, rgbToHex(shuffledColors[1].r, shuffledColors[1].g, shuffledColors[1].b));
                borderGradient.addColorStop(1, rgbToHex(shuffledColors[2].r, shuffledColors[2].g, shuffledColors[2].b));
            } else {
                borderGradient.addColorStop(0, rgbToHex(shuffledColors[0].r, shuffledColors[0].g, shuffledColors[0].b));
                borderGradient.addColorStop(1, rgbToHex(shuffledColors[1].r, shuffledColors[1].g, shuffledColors[1].b));
            }
            
            // Draw outer border
            ctx.strokeStyle = borderGradient;
            ctx.lineWidth = borderWidth;
            ctx.strokeRect(borderWidth/2, borderWidth/2, canvasWidth - borderWidth, canvasHeight - borderWidth);
            
            // Add inner subtle white border for extra elegance
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(borderWidth + 1, borderWidth + 1, canvasWidth - (borderWidth + 1) * 2, canvasHeight - (borderWidth + 1) * 2);
            
            ctx.restore();

            // Add watermark if provided
            const watermarkText = document.getElementById('watermarkInput').value.trim();
            if (watermarkText) {
                ctx.save();
                
                // Set font properties - using a clean, modern font
                const fontSize = Math.max(14, Math.min(canvasWidth, canvasHeight) * 0.035);
                ctx.font = `500 ${fontSize}px 'SF Pro Display', 'Segoe UI', 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif`;
                
                // Measure text for backdrop sizing
                const textMetrics = ctx.measureText(watermarkText);
                const textWidth = textMetrics.width;
                const textHeight = fontSize;
                
                // Backdrop properties
                const padding = fontSize * 0.4;
                const backdropWidth = textWidth + (padding * 2);
                const backdropHeight = textHeight + (padding * 1.2);
                const margin = 20;
                const backdropRadius = fontSize * 0.3;
                
                // Position backdrop in bottom right
                const backdropX = canvasWidth - margin - backdropWidth;
                const backdropY = canvasHeight - margin - backdropHeight;
                
                // Draw backdrop with rounded corners
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.beginPath();
                ctx.roundRect(backdropX, backdropY, backdropWidth, backdropHeight, backdropRadius);
                ctx.fill();
                
                // Draw text on backdrop
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    watermarkText, 
                    backdropX + backdropWidth / 2, 
                    backdropY + backdropHeight / 2
                );
                
                ctx.restore();
            }

            // Show the preview
            document.getElementById('generatedPreview').style.display = 'block';
            
            // Set up button functionality
            document.getElementById('refreshBtn').onclick = () => {
                drawSocialImage();
            };
            
            document.getElementById('downloadBtn').onclick = () => {
                const link = document.createElement('a');
                link.download = `${currentPlatformSettings.platformName.replace(/\s+/g, '_')}_${Date.now()}.png`;
                // Export at maximum quality
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
            };
            
            // Set up edit button
            document.getElementById('editImageBtn').onclick = () => {
                startImageEditor();
            };
        }

        // Image Editor Functions
        function startImageEditor() {
            isEditing = true;
            const imageEditor = document.getElementById('imageEditor');
            const canvas = document.getElementById('socialCanvas');
            
            // Create editor canvas overlay
            if (!editorCanvas) {
                editorCanvas = document.createElement('canvas');
                editorCanvas.style.position = 'absolute';
                editorCanvas.style.top = '0';
                editorCanvas.style.left = '0';
                editorCanvas.style.cursor = 'crosshair';
                editorCanvas.style.borderRadius = '10px';
                editorCanvas.style.pointerEvents = 'auto';
                editorCtx = editorCanvas.getContext('2d');
                
                // Add event listeners
                editorCanvas.addEventListener('mousedown', startDrawing);
                editorCanvas.addEventListener('mousemove', draw);
                editorCanvas.addEventListener('mouseup', stopDrawing);
                editorCanvas.addEventListener('click', handleCanvasClick);
                
                imageEditor.appendChild(editorCanvas);
            }
            
            // Always update canvas dimensions to match main canvas
            const rect = canvas.getBoundingClientRect();
            editorCanvas.width = canvas.width;
            editorCanvas.height = canvas.height;
            editorCanvas.style.width = rect.width + 'px';
            editorCanvas.style.height = rect.height + 'px';
            
            // Clear any previous editor content
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            textElements = []; // Clear text elements array
            editHistory = []; // Clear edit history
            
            // Save current state for undo
            saveState();
            
            // Show editor
            imageEditor.style.display = 'block';
            
            // Set up toolbar events
            setupEditorEvents();
        }

        function setupEditorEvents() {
            // Tool buttons
            document.getElementById('addTextBtn').onclick = () => {
                currentTool = 'text';
                hideAllPickers();
                document.getElementById('textInputModal').style.display = 'block';
            };
            
            document.getElementById('drawBtn').onclick = () => {
                currentTool = 'draw';
                hideAllPickers();
                document.getElementById('colorPicker').style.display = 'block';
                document.getElementById('brushSizePicker').style.display = 'block';
            };
            
            document.getElementById('arrowBtn').onclick = () => {
                currentTool = 'arrow';
                hideAllPickers();
                document.getElementById('colorPicker').style.display = 'block';
                document.getElementById('brushSizePicker').style.display = 'block';
            };
            
            document.getElementById('shapeBtn').onclick = () => {
                currentTool = 'shape';
                hideAllPickers();
                document.getElementById('colorPicker').style.display = 'block';
                document.getElementById('brushSizePicker').style.display = 'block';
                document.getElementById('shapeSelector').style.display = 'block';
            };
            
            document.getElementById('undoBtn').onclick = () => {
                undoLastAction();
            };
            
            document.getElementById('doneEditingBtn').onclick = () => {
                finishEditing();
            };
            
            // Color picker
            document.querySelectorAll('.color-option').forEach(option => {
                option.onclick = () => {
                    currentColor = option.dataset.color;
                    document.querySelectorAll('.color-option').forEach(o => o.style.border = '2px solid #ddd');
                    option.style.border = '3px solid #333';
                };
            });
            
            // Brush size picker
            document.querySelectorAll('.brush-size').forEach(size => {
                size.onclick = () => {
                    currentBrushSize = parseInt(size.dataset.size);
                    document.querySelectorAll('.brush-size').forEach(s => s.style.opacity = '0.5');
                    size.style.opacity = '1';
                };
            });
            
            // Shape selector
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.onclick = () => {
                    currentShape = btn.dataset.shape;
                    document.querySelectorAll('.shape-btn').forEach(b => b.style.background = '#f3f4f6');
                    btn.style.background = '#e5e7eb';
                };
            });
            
            // Text modal
            document.getElementById('cancelTextBtn').onclick = () => {
                document.getElementById('textInputModal').style.display = 'none';
                document.getElementById('textInput').value = '';
            };
            
            document.getElementById('addTextConfirmBtn').onclick = () => {
                const text = document.getElementById('textInput').value.trim();
                if (text) {
                    currentTool = 'text';
                    document.getElementById('textInputModal').style.display = 'none';
                    // Text will be placed on next click
                }
            };
        }

        function hideAllPickers() {
            document.getElementById('colorPicker').style.display = 'none';
            document.getElementById('brushSizePicker').style.display = 'none';
            document.getElementById('shapeSelector').style.display = 'none';
        }

        function getCanvasCoordinates(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / rect.width;
            const scaleY = editorCanvas.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            const coords = getCanvasCoordinates(e);
            startX = coords.x;
            startY = coords.y;
            
            // Check if clicking on existing text for dragging
            const clickedTextIndex = getTextAtPosition(coords.x, coords.y);
            if (clickedTextIndex !== -1) {
                isDragging = true;
                draggedTextIndex = clickedTextIndex;
                const textElement = textElements[clickedTextIndex];
                dragOffset.x = coords.x - textElement.x;
                dragOffset.y = coords.y - textElement.y;
                editorCanvas.style.cursor = 'move';
                return;
            }
            
            if (!currentTool) return;
            
            if (currentTool === 'draw') {
                isDrawing = true;
                editorCtx.beginPath();
                editorCtx.moveTo(startX, startY);
            } else if (currentTool === 'arrow' || currentTool === 'shape') {
                isDrawingArrow = currentTool === 'arrow';
                isDrawingShape = currentTool === 'shape';
                saveState();
            }
        }

        function draw(e) {
            const coords = getCanvasCoordinates(e);
            
            // Handle text dragging
            if (isDragging && draggedTextIndex !== -1) {
                const textElement = textElements[draggedTextIndex];
                textElement.x = coords.x - dragOffset.x;
                textElement.y = coords.y - dragOffset.y;
                redrawAllElements();
                return;
            }
            
            if (!isDrawing && !isDrawingArrow && !isDrawingShape) return;
            
            if (isDrawing) {
                editorCtx.lineWidth = currentBrushSize;
                editorCtx.lineCap = 'round';
                editorCtx.strokeStyle = currentColor;
                editorCtx.lineTo(coords.x, coords.y);
                editorCtx.stroke();
                editorCtx.beginPath();
                editorCtx.moveTo(coords.x, coords.y);
            } else if (isDrawingArrow || isDrawingShape) {
                // Clear and redraw for preview
                restoreState();
                
                if (isDrawingArrow) {
                    drawArrow(startX, startY, coords.x, coords.y);
                } else if (isDrawingShape) {
                    drawShape(startX, startY, coords.x, coords.y);
                }
            }
        }

        function stopDrawing(e) {
            // Handle text dragging end
            if (isDragging) {
                isDragging = false;
                draggedTextIndex = -1;
                editorCanvas.style.cursor = 'crosshair';
                saveState();
                return;
            }
            
            if (isDrawing) {
                isDrawing = false;
                saveState();
            } else if (isDrawingArrow || isDrawingShape) {
                const coords = getCanvasCoordinates(e);
                
                if (isDrawingArrow) {
                    drawArrow(startX, startY, coords.x, coords.y);
                } else if (isDrawingShape) {
                    drawShape(startX, startY, coords.x, coords.y);
                }
                
                isDrawingArrow = false;
                isDrawingShape = false;
                saveState();
            }
        }

        function handleCanvasClick(e) {
            if (currentTool === 'text') {
                const coords = getCanvasCoordinates(e);
                addTextToCanvas(coords.x, coords.y);
            }
        }

        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 20;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            editorCtx.strokeStyle = currentColor;
            editorCtx.lineWidth = currentBrushSize;
            editorCtx.lineCap = 'round';
            
            // Draw line
            editorCtx.beginPath();
            editorCtx.moveTo(fromX, fromY);
            editorCtx.lineTo(toX, toY);
            editorCtx.stroke();
            
            // Draw arrowhead
            editorCtx.beginPath();
            editorCtx.moveTo(toX, toY);
            editorCtx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            editorCtx.moveTo(toX, toY);
            editorCtx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            editorCtx.stroke();
        }

        function drawShape(startX, startY, endX, endY) {
            editorCtx.strokeStyle = currentColor;
            editorCtx.lineWidth = currentBrushSize;
            
            if (currentShape === 'rectangle') {
                const width = endX - startX;
                const height = endY - startY;
                editorCtx.strokeRect(startX, startY, width, height);
            } else if (currentShape === 'circle') {
                const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                editorCtx.beginPath();
                editorCtx.arc(startX, startY, radius, 0, 2 * Math.PI);
                editorCtx.stroke();
            }
        }

        function addTextToCanvas(x, y) {
            const text = document.getElementById('textInput').value.trim();
            const fontSize = document.getElementById('fontSizeSelect').value;
            const fontFamily = document.getElementById('fontFamilySelect').value;
            
            if (!text) return;
            
            // Scale font size for high-res canvas
            const scaledFontSize = fontSize * (editorCanvas.width / 600);
            
            // Store text element for dragging
            const textElement = {
                text: text,
                x: x,
                y: y,
                fontSize: scaledFontSize,
                fontFamily: fontFamily,
                color: currentColor
            };
            textElements.push(textElement);
            
            // Draw the text
            drawTextElement(textElement);
            
            // Clear input
            document.getElementById('textInput').value = '';
            
            saveState();
        }
        
        function drawTextElement(textElement) {
            editorCtx.font = `${textElement.fontSize}px ${textElement.fontFamily}`;
            editorCtx.textAlign = 'center';
            editorCtx.textBaseline = 'middle';
            
            // Add text background for better readability
            const textMetrics = editorCtx.measureText(textElement.text);
            const textWidth = textMetrics.width;
            const textHeight = textElement.fontSize;
            const padding = 10;
            
            // Draw background
            editorCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            editorCtx.fillRect(
                textElement.x - textWidth/2 - padding,
                textElement.y - textHeight/2 - padding,
                textWidth + padding * 2,
                textHeight + padding * 2
            );
            
            // Draw text
            editorCtx.fillStyle = textElement.color;
            editorCtx.fillText(textElement.text, textElement.x, textElement.y);
        }
        
        function getTextAtPosition(x, y) {
            for (let i = textElements.length - 1; i >= 0; i--) {
                const textElement = textElements[i];
                editorCtx.font = `${textElement.fontSize}px ${textElement.fontFamily}`;
                const textMetrics = editorCtx.measureText(textElement.text);
                const textWidth = textMetrics.width;
                const textHeight = textElement.fontSize;
                const padding = 10;
                
                if (x >= textElement.x - textWidth/2 - padding &&
                    x <= textElement.x + textWidth/2 + padding &&
                    y >= textElement.y - textHeight/2 - padding &&
                    y <= textElement.y + textHeight/2 + padding) {
                    return i;
                }
            }
            return -1;
        }
        
        function redrawAllElements() {
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            
            // Redraw all text elements
            textElements.forEach(textElement => {
                drawTextElement(textElement);
            });
        }

        function saveState() {
            editHistory.push(editorCtx.getImageData(0, 0, editorCanvas.width, editorCanvas.height));
            if (editHistory.length > 10) {
                editHistory.shift(); // Keep only last 10 states
            }
        }

        function restoreState() {
            if (editHistory.length > 0) {
                const lastState = editHistory[editHistory.length - 1];
                editorCtx.putImageData(lastState, 0, 0);
            }
        }

        function undoLastAction() {
            if (editHistory.length > 1) {
                editHistory.pop(); // Remove current state
                const previousState = editHistory[editHistory.length - 1];
                editorCtx.putImageData(previousState, 0, 0);
            } else if (editHistory.length === 1) {
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                editHistory = [];
            }
        }

        function finishEditing() {
            // Create a temporary canvas to preserve the current main canvas content
            const mainCanvas = document.getElementById('socialCanvas');
            const mainCtx = mainCanvas.getContext('2d');
            
            // Create temporary canvas to store current main canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = mainCanvas.width;
            tempCanvas.height = mainCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Copy current main canvas to temp
            tempCtx.drawImage(mainCanvas, 0, 0);
            
            // Clear main canvas and redraw everything
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            
            // First draw the temp canvas (original content)
            mainCtx.drawImage(tempCanvas, 0, 0);
            
            // Then draw all editor content on top
            mainCtx.drawImage(editorCanvas, 0, 0);
            
            // Clear editor
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            editHistory = [];
            textElements = []; // Clear text elements array
            
            // Hide editor
            document.getElementById('imageEditor').style.display = 'none';
            hideAllPickers();
            document.getElementById('textInputModal').style.display = 'none';
            
            isEditing = false;
            currentTool = null;
        }

        function resetUploader() {
            // Reset file input
            fileInput.value = '';
            
            // Hide all sections except upload
            uploadSection.style.display = 'block';
            loading.style.display = 'none';
            imagePreview.style.display = 'none';
            paletteSection.style.display = 'none';
            
            // Clear previous data
            colorPalette.innerHTML = '';
            previewImg.src = '';
            moodDescription.textContent = 'Click on any color to copy its hex code!';
            extractedColors = [];
            originalImage = null;
            document.getElementById('generatedPreview').style.display = 'none';
            
            // Reset dynamic styling
            const mainContent = document.querySelector('.main-content');
            mainContent.classList.remove('with-palette');
            previewImg.style.border = '4px solid transparent';
            previewImg.style.background = '';
            previewImg.style.backgroundClip = '';
            previewImg.style.boxShadow = '0 10px 30px rgba(0,0,0,0.2)';
        }
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96c01b1c805531a5',t:'MTc1NDY2NzU2MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
